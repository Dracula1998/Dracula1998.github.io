# 计算机系统原理笔记

### 一、系统的概念

### 二、数据的机器级表示与处理

* 一个附属的补码等于模减该负数的绝对值
* 对于某一确定的模，某数减去小于模的另一数，总可以用该数加上另一数负数的补码来代替
* 若同时有无符号和带符号证书，则C编译器将带符号整数强制转换为无符号数
* 规格化尾数的小数点后第一位总是1，故规定第一位默的“1”不明显表示出来。这样可用23个数位表示24位尾数。
* 在浮点数中，除数为0的结果是无穷大，不是溢出异常。（整数除0为异常）
* 浮点数的种类
  * 无穷大：阶码：全1，尾数：全0
  * 非数（NaN）：阶码：全1，尾数：非0
  * 0：全0（符号位可随意） 
  * 非规格化数：阶码：全0，尾数：非0


* 大端与小端存储（都是以数据占用的最小的地址为数据地址）
  * 大端：MSB的地址是数的地址，
  * 小端：LSB的地址是数的地址，

* 存储器是按字节编址，每次只能读写某个字地址开始的四个单元中连续的1,2,3或4个字节，边界不对齐虽然节省了空间，但是增加了访存次数

* 运算
  * 移位
    * 无符号数：逻辑左移，逻辑右移：高（低）位移出，低（高）位补0，可能溢出（若高位移出的是1，则左移是发生溢出）
    * 带符号整数：算数左移，算数右移
      * 左移：高位移出，低位补0，可能溢出（若移出的位不等于新的符号位，则溢出）
      * 右移：低位移出，高位补符，坑发生有效数据丢失
  * 位拓展和位截断运算
    * 类型转换时可能需要数据拓展或截断
      * 拓展：短转长
        * 无符号数：0拓展，前面补0
        * 带符号整数：符号拓展，前面补符
      * 截断：
        * 长转短：强制将高位丢弃，故可能发生溢出

### 四-五、ARM指令集架构

##### CISC（复杂指令集）

##### RISC（精简指令集）

* 80-20规律，典型程序中80%的语句仅仅使用处理机中20%的指令
* 执行频度高的简单指令，因复杂指令的存在执行速度无法提高
* 32位RISC体系结构
  * 数据处理指令只能在寄存器上操作
  * 三操作符格式
  * 为了高速的位操作将ALU与移位器混合
  * 绝大多数指令在单个时钟周期内执行
  * 每条指令都可以被有条件的执行

##### ARM指令与寻址方式（具体的指令格式建议打印PPT）：略

###### 立即数寻址

MOV R0, #0x55;

###### 寄存器寻址

MOV R0, R1

###### 寄存器移位寻址

* 逻辑左移：MOV R0, R1, LSL #5; R0 = R1 << 5
* 逻辑右移：MOV R0, R1, LSR #5; R0 = R1 >> 5
* 算数右移：MOV R0, R1, ASR #5; R0 = R1 >> 5
* 循环右移：MOV R0, R1, ROR #5; R0 = R1 >> 5

* 带拓展的循环右移：MOV R0, R1, RRX #5; R0 = R1 >> 5（最左端由标志位C填充）

###### 寄存器间接寻址

LDR R0, [R1]

###### 基址变址寻址

LDR R0, [R1, #5]

###### 相对寻址

BEQ process1（跳转至process1，process1是相对于PC的偏移量）

process1：

###### 多寄存器寻址

LDMIA R0!, {R1-R5};

* R1=[R0], R2=[R0+4]......,R5=[R0+16]
* 一条指令课实现一组寄存器值的传送。连续的寄存器用“-”，不连续用“，”
* IA表示在完成一次Load操作后R0自增4（Increase After）
* 注：一定注意最后R0的值会自增

###### 块拷贝寻址

可实现连续地址数据从存储器的某一位置拷贝到另一位置

LDMIA R0!, {R1-R5}; 从以R0的值为其实地址的存储中取出五个字的数据

STMIA R0!, {R1-R5};将取出的数据存入以R1的值为起始地址的存储单元中

###### 堆栈寻址

STMFD R13!, {R0-R4} 将R0-R4中的数据压入堆栈,**R13**为堆栈指针

STMFD R13!, {R0-R4} 将R0-R4中的数据出栈,**R13**为堆栈指针

##### 数据处理指令

* MOV数据传送指令	
  * MOV{<cond>}{S}  <Rd>,<op1>;
  * 指定相同的寄存器来实现NOP操作，还可以移位一个寄存器

* MVN数据取反传送指令
  * MVN{<cond>}{S}  <Rd>,<op1>;
  * 将op1表示的值按位取反传送到目的寄存器Rd中

* ADD加法指令
  * ADD{<cond>}{S}  <Rd>,<Rn>,<op2>;
  * Rd = Rn + op2

* ADC带进位加法指令

  * ADC{<cond>}{S}  <Rd>,<Rn>,<op2>; 
  * Rd= Rn + op2 + carry （标识寄存器）

  实现64位数的加法运算

  第一个 64 位数: 寄存器 R2、R3;低位存在R2

  第二个 64 位数: 寄存器 R4、R5。低位存在R4 

   ADDS R0, R2, R4 ;        加低位的字 

   ADC   R1, R3, R5 ;        加下一个字，不带进位

* SUB减法指令
  * SUB{<cond>}{S}  <Rd>,<Rn>,<op2>;
  * Rd = Rn - op2

* RSB反向减法指令
  * RSB{<cond>}{S}  <Rd>,<Rn>,<op2>；
  * Rd = op2 – Rn

* SBC带借位减法指令

  * SBC{<cond>}{S}  <Rd>,<Rn>,<op2>;
  * Rd= Rn - op2 - !carry 

  第一个64位操作数存放在寄存器R2，R3中；低位存在R2

  第二个64位操作数存放在寄存器R4，R5中；低位存在R4，64位结果存放在R0，R1中。

  SUBS  R0，R2，R4； 低32位相减，S表示结果影响条件标志位的值

  SBC  R1，R3，R5；  高32位相减

* RSC带借位的反向减法指令

  * RSC{<cond>}{S} <Rd>,<Rn>,<op2>;
  * Rd = op2 - Rn - !carry

* MLA 32位乘加指令
  * MLA{<cond>}{S}  <Rd>,<Rn>,<op2>,<op3>;
  * Rd =( Rn * op2) + op3

* AND逻辑与指令（ORR或， EOR异或）
  * AND{<cond>}{S}  <Rd>,<Rn>,<op2>;
  * Rd = Rn AND op2

* BIC位清除指令（相当于集合做差， 集合Rn-op2）
  * BIC{<cond>}{S}  <Rd>,<Rn>,<op2>; 
  * Rd = Rn AND (!op2)

* CMP比较指令（只修改标志位，不存储结果）
  * CMP{<cond>}  <Rn>,<op1>;
  * status = Rn – op1 

* TST位测试指令
  * TST{<cond>}  <Rn>,<op1>; 
  * Status = Rn AND op1

##### 跳转指令

* 跳转
  * B{<cond>}  <addr>;

* BL 带返回的跳转
  * BL{<cond>}  <addr>;
  * 同B指令，但BL指令执行跳转操作的同时，还将PC（寄存器R15）的值保存到LR寄存器（寄存器R14）中。该指令用于实现子程序调用 。程序的返回可通过把LR寄存器的值复制到PC寄存器中来实现
  * MOV  R15，R14； 子程序返回

##### 条件执行语句

ADDNE等

* 减少指令数量->较小的内存占用

* 更流畅的流水线执行->更高的执行效率

  --如果BEQ指令执行，流水线需要3个额外的时钟周期进行流水线重新填充(pipeline refill penalty)

* 适用于较小的分支体（如只含有1-2条指令的if, while等）

##### Load/Store

###### 字数据加载

* 操作数地址为基址加变址，执行后基址不变
  * LDR Rd, [Rn, Rm]
  * 执行后Rn不变

* 操作数地址为基址加变址，执行后基址改变
  * LDR Rd, [Rn, Rm]!
  * Rn=Rn+Rm

* 操作数地址为基址，执行后基址改变
  * LDR  Rd，[Rn]，Rm 
  * [Rn]->Rd; Rn+Rm->Rn

###### 字数据存储

* STR{<cond>}  <Rd>,<addr>；
  * 与LDR相同

###### LDM批量数据加载指令

* LDM{<cond>}{<type>} <Rn>{!}，<regs>{^}；
  * ！：选用后Rn的值最终会写入基址寄存器
  * 带有^表示异常模式寄存器,此时若LDM包含R15，装载 R15 时恢复 SPSR至CPSR 位。

* STM{<cond>}{<type>}  <Rn>{!}，<regs>{^}；
  * 同LDM

* 注：批量数据存储、加载时，低编号寄存器对应低地址存储单元，与寄存器在指令中出现的次序无关。